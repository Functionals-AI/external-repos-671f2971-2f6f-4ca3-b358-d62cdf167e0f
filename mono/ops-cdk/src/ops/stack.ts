import { Stack, StackProps, CfnOutput, Fn } from 'aws-cdk-lib'
import * as sns from 'aws-cdk-lib/aws-sns'
import * as subs from 'aws-cdk-lib/aws-sns-subscriptions'
import * as ec2 from 'aws-cdk-lib/aws-ec2'
import { Construct } from 'constructs'
import { IConfig } from '@mono/common/lib/config'
import { createVpc } from './vpc'


export class OpsStack extends Stack {
  constructor(scope: Construct, id: string, props: StackProps, config: IConfig) {
    super(scope, id, props)

    const {vpc} = createVpc(this, {cidr: config.ops_cdk.vpcs.default.cidrBlock})

    new CfnOutput(this, 'OpsVpcIdOutput', {
      value: vpc.vpcId,
      description: 'Ops Vpc Id',
      exportName: Fn.join('-', [Fn.ref('AWS::StackName'), 'VpcId'])
    })

    // VPCs need to be created and added to config before VPC peering can be set up
    if (config.isProduction) {
      const peer = new ec2.CfnVPCPeeringConnection(this, 'CommonPeerConnection', {
        vpcId: config.ops_cdk.vpcs.default.id,
        peerVpcId: config.common_cdk.vpcs.default.id,
      })
  
      const vpnSubnets = config.ops_cdk.vpcs.default.subnets.vpn
  
      if (vpnSubnets) {
        vpnSubnets.forEach(({ routeTableId }, index) => {
          new ec2.CfnRoute(this, `RouteFromVpnSubnet${index}ToCommonVpc`, {
            routeTableId,
            destinationCidrBlock: config.common_cdk.vpcs.default.cidrBlock,
            vpcPeeringConnectionId: peer.ref,
          })
        })
      }

      // Create peering routes from rds subnets in common vpc to ops vpc
      const rdsSubnets = config.common_cdk.vpcs.default.subnets.rds

      if (rdsSubnets) {
        const routeTableIds = []

        for (let subnet of rdsSubnets) {
          if (!routeTableIds.includes(subnet.routeTableId)) {
            routeTableIds.push(subnet.routeTableId)
          }
        }

        for (let [index, routeTableId] of routeTableIds.entries()) {
          new ec2.CfnRoute(this, `RouteFromCommonVpcRdsSubnet${index}ToOpsVpc`, {
            routeTableId,
            destinationCidrBlock: config.ops_cdk.vpcs.default.cidrBlock,
            vpcPeeringConnectionId: peer.ref,
          })  
        }
      }

      // Create peering routes from internal subnets in common vpc to ops vpc
      const internalSubnets = config.common_cdk.vpcs.default.subnets.internal

      if (internalSubnets) {
        const routeTableIds = []

        for (let subnet of internalSubnets) {
          if (!routeTableIds.includes(subnet.routeTableId)) {
            routeTableIds.push(subnet.routeTableId)
          }
        }

        for (let [index, routeTableId] of routeTableIds.entries()) {
          new ec2.CfnRoute(this, `RouteFromCommonVpcInternalSubnet${index}ToOpsVpc`, {
            routeTableId,
            destinationCidrBlock: config.ops_cdk.vpcs.default.cidrBlock,
            vpcPeeringConnectionId: peer.ref,
          })  
        }
      }
    }

    //
    // Lack of referrals for CalOptima triggers an alert via this topic.
    //
    const alertsCalOptimaReferralsTopic = new sns.Topic(this, 'OpsAlertsCalOptimaReferralsTopic', {
      displayName: 'Ops Alerts CalOptima Referrals',
      topicName: `ops-alerts-caloptima-referrals`,
    })

    alertsCalOptimaReferralsTopic.addSubscription(new subs.EmailSubscription('ops@foodsmart.com'))

    //
    // Low inventory of instacart codes triggers an alert via this topic.
    //
    const alertsIncentivesInstacartTopic = new sns.Topic(this, 'OpsAlertsIncentivesInstacartTopic', {
      displayName: 'Ops Alerts Incentives Instacart',
      topicName: `ops-alerts-incentives-instacart`,
    })

    alertsIncentivesInstacartTopic.addSubscription(new subs.EmailSubscription('ops@foodsmart.com'))

    //
    // Log entries with a level of 'error' trigger an alert via publication
    // to this topic.
    //
    const alertsLogsTopic = new sns.Topic(this, 'OpsAlertsLogsTopic', {
      displayName: 'Ops Alerts Logs',
      topicName: `ops-alerts-logs`,
    })

    alertsLogsTopic.addSubscription(new subs.EmailSubscription('ops-logs@foodsmart.com'))

    //
    // Flow CW alarms which go into the 'In Alarm' state, publish to the alertsFlowsTopic.
    //
    // Note, this is now generated by common-cdk alarms code for all flows.
    //
    // const alertsFlowsTopic = new sns.Topic(this, 'OpsAlertsFlowsTopic', {
    //   displayName: 'Ops Alerts Flows',
    //   topicName: `ops-alerts-flows`,
    // })
    //
    // alertsFlowsTopic.addSubscription(new subs.EmailSubscription('ops@foodsmart.com'))
    //
  }
}