import { CfnOutput, CfnParameter, Duration, Fn, Stack, StackProps, RemovalPolicy } from 'aws-cdk-lib'
import { Construct } from 'constructs'
import * as kms from 'aws-cdk-lib/aws-kms'
import * as iam from 'aws-cdk-lib/aws-iam'
import * as ec2 from 'aws-cdk-lib/aws-ec2'
import * as ecs from 'aws-cdk-lib/aws-ecs'
import * as ecsPatterns from 'aws-cdk-lib/aws-ecs-patterns'
import * as events from 'aws-cdk-lib/aws-events'
import { CloudWatchLogGroup } from 'aws-cdk-lib/aws-events-targets'
import * as rds from 'aws-cdk-lib/aws-rds'
import { LogGroup, RetentionDays } from 'aws-cdk-lib/aws-logs'

import { IConfig } from '@mono/common/lib/config'
import { ScriptNames } from '@mono/common-tasks/lib/scripts'

import Config from '../config'
import { factory as buildFactory } from '../build'
import { createVpc } from '../vpc'
import { createECSSecurityGroupName, createLogGroupName } from '../naming'
import Secrets from '../secrets'
import { eventBusName } from '@mono/common/lib/warehouse/events'

const _CLUSTER_NAME = 'foodsmart'
const _CLUSTER_NAME_V1 = 'foodsmart-v1'
const _DATABASE_NAME = 'foodsmart'
const _ADMIN_USERNAME = 'master'
const _ADMIN_USERNAME_SECRET_NAME = 'mono/foodsmart/store/admin'
const _ADMIN_USERNAME_SECRET_NAME_V1 = 'mono/foodsmart/store-v1/admin'

/**
 * Resources for a Serverless postgres cluster.
 * 
 * V2 will be created manually and the resourcees generated by this stack should be used.
 * WRT connecting via SSL, the following certificate bundle should be used:
 * 
 * https://truststore.pki.rds.amazonaws.com/global/global-bundle.pem
 */
export class CommonStoreStack extends Stack {
  constructor(scope: Construct, id: string, props: StackProps, config: IConfig) {
    super(scope, id, props)

    const cdkConfig = Config.getConfig()

    const { subnetsRDS } = cdkConfig;

    const clusterAdminCredentials = rds.Credentials.fromGeneratedSecret(_ADMIN_USERNAME, {
      secretName: _ADMIN_USERNAME_SECRET_NAME
    })

    const clusterEncryptionKey = new kms.Key(this, 'FoodsmartStoreEncryptionKey', {
      enabled: true,
      alias: 'foodsmart/serverless-postgres',
      enableKeyRotation: true,
      keySpec: kms.KeySpec.SYMMETRIC_DEFAULT,
    })

    const { vpc, subnets } = createVpc(this, cdkConfig)

    const rdsSubnets = vpc.selectSubnets({
      subnets: subnetsRDS.map(subnet => ec2.Subnet.fromSubnetAttributes(this, subnet.subnetId, subnet))
    })

    const clusterSecurityGroup = new ec2.SecurityGroup(this, 'FoodsmartStoreSecurityGroup', {
      description: 'Foodsmart store RDS security group.',
      vpc: vpc,
      securityGroupName: `${config.env}-sg-rds-foodsmart`
    })

    const vpnSecurityGroup = ec2.SecurityGroup.fromSecurityGroupId(this, 'AWSVpnSecurityGroup', config.common_cdk.vpcs.default.securityGroups.vpn.id)

    clusterSecurityGroup.addIngressRule(vpnSecurityGroup, ec2.Port.tcp(5432), 'VPN access to RDS Foodsmart Cluster')

    const clusterSubnetGroup = new rds.SubnetGroup(this, 'FoodsmartStoreSubnetGroup', {
      description: 'Foodsmart Postgres store subnet group.',
      vpc: vpc,
      subnetGroupName: `${config.env}-rds-foodsmart`,
      vpcSubnets: rdsSubnets,
    })

    const foodsmartDBClusterParameterGroup = new rds.ParameterGroup(this, 'FoodsmartServerlessV2ClusterParameterGroup', {
      engine: rds.DatabaseClusterEngine.auroraPostgres({
        version: rds.AuroraPostgresEngineVersion.VER_13_6,
      }),
      description: 'Foodsmart postgres Serverless v2 parameter group.',
      parameters: {
        'rds.force_ssl': '1'
      }
    })

    new CfnOutput(this, 'CommonStoreSecurityGroupIdOutput', {
      exportName: Fn.join('-', [Fn.ref('AWS::StackName'), 'ClusterSecurityGroupId']),
      value: clusterSecurityGroup.securityGroupId,
      description: 'Common store security group ID.',
    })

    if (config.env === 'development') {
      //
      // A serverless v2 cluster will be created manually. In the future, when
      // the CDK / Cloudformation support creation of a v2 cluster from a snapshot
      // one will be created via the CDK here. Leave this code here for reference.
      //
      // Note, AWS Cloudformation DOES NOT support Serverless V2. The CDK relies on
      // Cloudformation. As a result, this is a serverless v1 cluster.
      //
      // With v1, the scaling attribute is used to specify min capacity / max capacity.
      // The scaling behaviour between v1 and v2 is different. V2 has a miniumim of 0.5 ACUs
      // where an ACU is to be thought of as 2GB of membory. in V1, the minimum is 2 ACUs.
      // The scaling behavior doubles if more is needed, and in V2, its incremental.
      // For v1, the scaling capacity is specified via the 'scaling' attribute. For V2, 
      // there is evidently a parameter value of ServerlessV2ScalingConfiguration, but
      // it is not clear how to specify the values, and if specified an error for of
      // 'Invalid / Unsupported DB Parameter' is produced.
      //
      // Also note, as of this writing, Serverless V2 supports a minimum of Postgress 13.6.
      // However, Serverless v1 ONLY supports 10.14 and 10.18 in us-west-2.
      //
      // Note, to connect using SSL, Postgress uses wildcard certificates:
      //
      // See: https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless-v2-administration.html#aurora-serverless-v2.tls
      //
      // The following root CA should be provided:
      //
      // https://www.amazontrust.com/repository/AmazonRootCA1.pem
      //

      const clusterAdminCredentialsV1 = rds.Credentials.fromGeneratedSecret(_ADMIN_USERNAME, {
        secretName: _ADMIN_USERNAME_SECRET_NAME_V1
      })

      const foodsmartDBClusterParameterGroupV1 = new rds.ParameterGroup(this, 'FoodsmartClusterParameterGroupV1', {
        engine: rds.DatabaseClusterEngine.auroraPostgres({
          version: rds.AuroraPostgresEngineVersion.VER_10_18,
        }),
        parameters: {
          'rds.force_ssl': '1'
        }
      })

      const cluster = new rds.ServerlessCluster(this, 'FoodsmartServerlessV1Cluster', { 
        clusterIdentifier: _CLUSTER_NAME_V1,
        engine: rds.DatabaseClusterEngine.auroraPostgres({
          version: rds.AuroraPostgresEngineVersion.VER_10_18,
        }),
        backupRetention: Duration.days(30),
        credentials: clusterAdminCredentialsV1,
        defaultDatabaseName: _DATABASE_NAME,
        deletionProtection: true,
        enableDataApi: true,
        //
        // parameterGroup: rds.ParameterGroup.fromParameterGroupName(this, 'ParameterGroup', 'default.aurora-postgresql10'),
        //
        // Create a group with parameters that can be customized. Relevant postgres parameters:
        //
        //  - rds.force_ssl: Do not allow falling back to non-ssl.
        //
        parameterGroup: foodsmartDBClusterParameterGroupV1,
        scaling: {
          minCapacity: rds.AuroraCapacityUnit.ACU_2, // default is 2 Aurora capacity units (ACUs)
          maxCapacity: rds.AuroraCapacityUnit.ACU_4, // default is 16 Aurora capacity units (ACUs)
        },
        securityGroups: [
          clusterSecurityGroup,
        ],
        storageEncryptionKey: clusterEncryptionKey,
        subnetGroup: clusterSubnetGroup,
        vpc: vpc,
      })
    }

    //
    // IAM / ECS related resources to support Fargate tasks.
    //

    const scriptsTaskImageTagParameter = new CfnParameter(this, 'ScriptsTaskImageBuildTag', {
      description: "Common scripts task image tag.",
      type: "String"
    })

    const redshiftFqManagedPolicy = new iam.ManagedPolicy(this, 'CommonRedshiftFederatedQueryPolicy', {
      description: 'Policy to faciliate Federated Queries to Redshift.',
      managedPolicyName: 'FoodsmartCommonRedshiftFederatedQueryPolicy',
      document: new iam.PolicyDocument({
        statements: [
          new iam.PolicyStatement(
            {
              actions: [
                'secretsmanager:GetResourcePolicy',
                'secretsmanager:GetSecretValue',
                'secretsmanager:DescribeSecret',
                'secretsmanager:ListSecretVersionIds'
              ],
              resources: [
                config.redshift.commonStore.fqSecretsmanagerArn
              ]
            }
          ),
          new iam.PolicyStatement(
            {
              actions: [
                'secretsmanager:GetRandomPassword',
                'secretsmanager:ListSecrets'
              ],
              resources: [ '*' ]
            }
          )
        ]
      })
    })

    const redshiftFqRole = new iam.Role(this, 'CommonRedshiftFederatedQueryRole', {
      assumedBy: new iam.ServicePrincipal('redshift.amazonaws.com'),
      description: 'Role to facilitate Redshift Federated Query to the AWS RDS Aurora Postgres common DB.',
      managedPolicies: [
        redshiftFqManagedPolicy
      ],
      roleName: 'FoodsmartCommonRedshiftFederatedQueryRole'
    })

    const ecsTaskSecurityGroup = new ec2.SecurityGroup(this, 'CommonClusterSecurityGroup', {
      securityGroupName: createECSSecurityGroupName(config, 'common', 'cluster'),
      vpc,
      allowAllOutbound: true,
    })

    const cluster = new ecs.Cluster(this, `CommonCluster`, {
      clusterName: 'Common',
      containerInsights: true,
      vpc,
    })

    const {repository} = buildFactory(this, 'common', {vpc, subnets, config: cdkConfig})

    const logGroup = new LogGroup(this, 'CommonWarehouseSyncTasksLogGroup', {
      logGroupName: createLogGroupName(config, 'common', 'warehouse-sync'),
      retention: RetentionDays.ONE_MONTH,
      removalPolicy: RemovalPolicy.DESTROY,
    })

    const task = new ecsPatterns.ScheduledFargateTask(this, 'CommonScheduledWarehouseSyncTask', {
      cluster,
      subnetSelection: subnets,
      securityGroups: [ecsTaskSecurityGroup],
      scheduledFargateTaskImageOptions: {
        environment: {
          NODE_ENV: config.env,
        },
        image: ecs.ContainerImage.fromEcrRepository(repository, scriptsTaskImageTagParameter.valueAsString),
        command: ['npm', 'run', 'script', ScriptNames.WarehouseSync],
        cpu: 2048,
        memoryLimitMiB: 8192,
        logDriver: ecs.LogDrivers.awsLogs({
          streamPrefix: ScriptNames.WarehouseSync,
          logGroup,
        }),
      },
      ruleName: `common-tasks.warehouse.sync`,
      schedule: events.Schedule.expression('cron(0 1 * * ? *)'),
      platformVersion: ecs.FargatePlatformVersion.LATEST,
    })

    const secrets = Secrets.getSecrets(this)

    secrets.grantRead(task.taskDefinition.taskRole)

    //
    // Need an event bus to communicate events such as "warehouse sync completed".
    //
    const eventBus = new events.EventBus(this, 'CommonWarehouseEventBus', {
      eventBusName: eventBusName,
    })

    const eventLoggerRule = new events.Rule(this, "CommonWarehouseEventLoggerRule", {
      description: "Log common warehouse events.",
      eventPattern: {
        region: [ config.aws.region ]
      },
      eventBus
    })

    const eventLogGroup = new LogGroup(this, 'CommonWarehouseEventLogGroup', {
      logGroupName: '/foodsmart/common/warehouse-events',
    })

    eventLoggerRule.addTarget(new CloudWatchLogGroup(eventLogGroup))

    eventBus.grantPutEventsTo(task.taskDefinition.taskRole)

  }
}